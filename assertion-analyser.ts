/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *       DO NOT EDIT THIS FILE
 *       For FCC testing purposes!
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

function objParser(str: string, init = 0) {
	// finds objects, arrays, strings, and function arguments
	// between parens, because they may contain ','
	const openSym: string[] = ["[", "{", '"', "'", "("];
	const closeSym: string[] = ["]", "}", '"', "'", ")"];
	let type = -2;
	let i = init || 0;
	for (i; i < str.length; i++) {
		type = openSym.indexOf(str[i]);
		if (type !== -1) break;
	}
	if (type === -1) return null;
	const open = openSym[type];
	const close = closeSym[type];
	let count = 1;
	let k = i + 1;
	for (k; k < str.length; k++) {
		if (open === '"' || open === "'") {
			if (str[k] === close) count--;
			if (str[k] === "\\") k++;
		} else {
			if (str[k] === open) count++;
			if (str[k] === close) count--;
		}
		if (count === 0) break;
	}
	if (count !== 0) return null;
	const obj = str.slice(i, k + 1);
	return {
		start: i,
		end: k,
		obj,
	};
}

function replacer(str: string) {
	// replace objects with a symbol ( __#n)
	let cnt = 0;
	const data = [];
	let newStr: string = str;
	let obj = objParser(newStr);

	while (obj) {
		data[cnt] = obj.obj;
		newStr = `${newStr.substring(
			0,
			obj.start
		)}__#${cnt++}${newStr.substring(obj.end + 1)}`;
		obj = objParser(newStr);
	}
	return {
		str: newStr,
		dictionary: data,
	};
}

function splitter(str: string): string[] {
	// split on commas, then restore the objects
	const strObj = replacer(str);
	let args = strObj.str.split(",");
	args = args.map((a: string) => {
		let m: any = a.match(/__#(\d+)/);
		let newA: string = a;
		while (m) {
			newA = newA.replace(/__#(\d+)/, strObj.dictionary[m[1]]);
			m = newA.match(/__#(\d+)/);
		}
		return newA.trim();
	});
	return args;
}

function assertionAnalyser(body: string): any {
	// already filtered in the test runner
	// // remove comments
	// body = body.replace(/\/\/.*\n|\/\*.*\*\//g, '');
	// // get test function body
	// body = body.match(/\{\s*([\s\S]*)\}\s*$/)[1];

	if (!body) return "invalid assertion";
	// replace assertions bodies, so that they cannot
	// contain the word 'assertion'

	const match = body.match(
		/(?:browser\s*\.\s*)?assert\s*\.\s*\w*\([\s\S]*\)/
	)[0];
	const s = replacer(match);
	// split on 'assertion'
	const splittedAssertions = s.str.split("assert");
	let assertions: string[] = splittedAssertions.slice(1);

	// match the methods
	const assertionBodies: number[] = [];
	const methods = assertions.map((a: string, i: number) => {
		const m: any = a.match(/^\s*\.\s*(\w+)__#(\d+)/);
		assertionBodies.push(parseInt(m[2], 10));
		const pre = splittedAssertions[i].match(/browser\s*\.\s*/)
			? "browser."
			: "";
		return pre + m[1];
	});
	if (
		methods.some(function (m: any) {
			return !m;
		})
	)
		return "invalid assertion";
	// remove parens from the assertions bodies
	const bodies = assertionBodies.map(function (b: any) {
		return s.dictionary[b].slice(1, -1).trim();
	});
	assertions = methods.map(function (m: any, i: number) {
		return {
			method: m,
			args: splitter(bodies[i]), // replace objects, split on ',' ,then restore objects
		};
	});
	return assertions;
}

export default assertionAnalyser;
